--- asn1c/unber.c	2015-12-08 14:39:33.282543533 +0100
+++ asn1c/unber.c	2015-12-07 10:46:18.382647000 +0100
@@ -779,4 +779,6 @@
 
 asn_enc_rval_t OCTET_STRING_encode_aper(asn_TYPE_descriptor_t *td, asn_per_constraints_t *cts, void *sptr, asn_per_outp_t *po) { asn_enc_rval_t er = { 0, 0, 0 }; (void)td; (void)cts; (void)sptr; (void)po; return er; }
 
+asn_comp_rval_t *  OCTET_STRING_compare(asn_TYPE_descriptor_t *td1, void *sptr1, asn_TYPE_descriptor_t *td2, void *sptr2) { (void)td1; (void)sptr1; (void)td2; (void)sptr2; return 0; }
+
 size_t xer_whitespace_span(const void *chunk_buf, size_t chunk_size) {  (void)chunk_buf; (void)chunk_size; return 0; }
--- libasn1compiler/asn1c_C.c	2015-12-08 14:39:33.366543533 +0100
+++ libasn1compiler/asn1c_C.c	2015-12-08 08:38:29.002565000 +0100
@@ -1082,6 +1082,8 @@
 	enum tvm_compat tv_mode;
 	enum etd_spec etd_spec;
 	char *p;
+  //char tmp_buf[512];
+  //int i = 0;
 
 	if(arg->embed) {
 		enum tnfmt tnfmt = TNF_CTYPE;
@@ -1243,7 +1245,8 @@
 	OUT("td->uper_decoder   = asn_DEF_%s.uper_decoder;\n",   type_name);
 	OUT("td->uper_encoder   = asn_DEF_%s.uper_encoder;\n",   type_name);
 	OUT("td->aper_decoder   = asn_DEF_%s.aper_decoder;\n",   type_name);
-	OUT("td->aper_encoder   = asn_DEF_%s.aper_encoder;\n",   type_name);
+  OUT("td->aper_encoder   = asn_DEF_%s.aper_encoder;\n",   type_name);
+  OUT("td->compare        = asn_DEF_%s.compare;\n",        type_name);
 	if(!terminal && !tags_count) {
 	  OUT("/* The next four lines are here because of -fknown-extern-type */\n");
 	  OUT("td->tags           = asn_DEF_%s.tags;\n",         type_name);
@@ -1413,6 +1416,39 @@
 	OUT("}\n");
 	OUT("\n");
 
+
+  //i = 0;
+  //while ((p[i] != '_') && (i < sizeof(tmp_buf))) {
+  //  tmp_buf[i] = p[i];
+  //  i++;
+  //}
+  //tmp_buf[i] = '\0';
+  // hack, only for s1ap
+  //if ((strcmp("S1ap", tmp_buf) == 0) || (strcmp("X2ap", tmp_buf) == 0))
+  //  OUT("#include \"%s-ProtocolIE-ID.h\"\n", tmp_buf);
+
+
+  p = MKID(expr);
+  if(HIDE_INNER_DEFS) OUT("static ");
+              OUT("asn_comp_rval_t * \n");
+  OUT("%s", p);
+  if(HIDE_INNER_DEFS) OUT("_%d", expr->_type_unique_index);
+    OUT("_compare(asn_TYPE_descriptor_t *td1,\n");
+  INDENTED(
+  OUT("\tvoid *structure1,\n");
+  OUT("\tasn_TYPE_descriptor_t *td2,\n");
+  OUT("\tvoid *structure2) {\n");
+  OUT("asn_comp_rval_t * res  = NULL;\n");
+  OUT("%s_%d_inherit_TYPE_descriptor(td1);\n",
+    p, expr->_type_unique_index);
+  OUT("%s_%d_inherit_TYPE_descriptor(td2);\n",
+    p, expr->_type_unique_index);
+  OUT("res = td1->compare(td1, structure1, td2, structure2);\n");
+  OUT("return res;\n");
+  );
+  OUT("}\n");
+  OUT("\n");
+
 	p = MKID(expr);
 	
 	if(HIDE_INNER_DEFS) OUT("static ");
@@ -1450,7 +1486,8 @@
 		OUT("per_type_decoder_f %s_decode_uper;\n", p);
 		OUT("per_type_encoder_f %s_encode_uper;\n", p);
 		OUT("per_type_decoder_f %s_decode_aper;\n", p);
-		OUT("per_type_encoder_f %s_encode_aper;\n", p);
+    OUT("per_type_encoder_f %s_encode_aper;\n", p);
+    OUT("type_compare_f     %s_compare;\n", p);
 		}
 	}
 
@@ -2501,6 +2538,7 @@
 			OUT("0, 0,\t/* No APER support, "
 				"use \"-gen-PER\" to enable */\n");
 		}
+    FUNCREF(compare);
 
 		if(!terminal || terminal->expr_type == ASN_CONSTR_CHOICE) {
 		//if(expr->expr_type == ASN_CONSTR_CHOICE) {
--- skeletons/ANY.c	2015-12-08 14:39:33.350543533 +0100
+++ skeletons/ANY.c	2015-11-26 14:40:56.547616000 +0100
@@ -24,7 +24,8 @@
 	OCTET_STRING_decode_uper,
 	OCTET_STRING_encode_uper,
 	OCTET_STRING_decode_aper,
-	OCTET_STRING_encode_aper,
+  OCTET_STRING_encode_aper,
+  OCTET_STRING_compare,
 	0, /* Use generic outmost tag fetcher */
 	0, 0, 0, 0,
 	0,	/* No PER visible constraints */
--- skeletons/asn_application.h	2015-12-08 14:39:12.674543554 +0100
+++ skeletons/asn_application.h	2015-12-07 14:36:32.950633000 +0100
@@ -9,7 +9,8 @@
 #define	_ASN_APPLICATION_H_
 
 #include "asn_system.h"		/* for platform-dependent types */
-#include "asn_codecs.h"		/* for ASN.1 codecs specifics */
+#include "asn_codecs.h"   /* for ASN.1 codecs specifics */
+#include "asn_compare.h"
 
 #ifdef __cplusplus
 extern "C" {
--- skeletons/asn_compare.h	1970-01-01 01:00:00.000000000 +0100
+++ skeletons/asn_compare.h	2015-12-08 10:34:58.090558000 +0100
@@ -0,0 +1,78 @@
+#ifndef	_ASN_COMPARE_H_
+#define	_ASN_COMPARE_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct asn_TYPE_descriptor_s;	/* Forward declaration */
+
+
+typedef enum COMPARE_ERR_CODE_e {
+  COMPARE_ERR_CODE_START = 0,
+  COMPARE_ERR_CODE_NONE = COMPARE_ERR_CODE_START,
+  COMPARE_ERR_CODE_NO_MATCH,
+  COMPARE_ERR_CODE_TYPE_MISMATCH,
+  COMPARE_ERR_CODE_TYPE_ARG_NULL,
+  COMPARE_ERR_CODE_VALUE_NULL,
+  COMPARE_ERR_CODE_VALUE_ARG_NULL,
+  COMPARE_ERR_CODE_CHOICE_NUM,
+  COMPARE_ERR_CODE_CHOICE_PRESENT,
+  COMPARE_ERR_CODE_CHOICE_MALFORMED,
+  COMPARE_ERR_CODE_SET_MALFORMED,
+  COMPARE_ERR_CODE_COLLECTION_NUM_ELEMENTS,
+  COMPARE_ERR_CODE_END
+} COMPARE_ERR_CODE_t;
+
+typedef struct asn_comp_rval_s {
+  enum COMPARE_ERR_CODE_e err_code;
+  char                   *name; // e_S1ap_ProtocolIE_ID not available for all ASN1 use (RRC vs S1AP, X2AP)
+  void                   *structure1;
+  void                   *structure2;
+  struct asn_comp_rval_s *next;
+} asn_comp_rval_t;
+
+#define COMPARE_CHECK_ARGS(aRg_tYpE_dEf1, aRg_tYpE_dEf2, aRg_vAl1, aRg_vAl2, rEsUlT) \
+    do {\
+      if ((aRg_tYpE_dEf1) && (aRg_tYpE_dEf2)) {\
+        if ((aRg_tYpE_dEf1->name) && (aRg_tYpE_dEf2->name)) {\
+          if (strcmp(aRg_tYpE_dEf1->name, aRg_tYpE_dEf2->name)) {\
+            rEsUlT           = (asn_comp_rval_t *)calloc(1, sizeof(asn_comp_rval_t));\
+            rEsUlT->err_code = COMPARE_ERR_CODE_TYPE_MISMATCH;\
+            rEsUlT->name     = aRg_tYpE_dEf1->name;\
+            return rEsUlT;\
+          }\
+        } else {\
+          if ((aRg_tYpE_dEf1->xml_tag) && (aRg_tYpE_dEf2->xml_tag)) {\
+            if (strcmp(aRg_tYpE_dEf1->xml_tag, aRg_tYpE_dEf2->xml_tag)) {\
+              rEsUlT           = (asn_comp_rval_t *)calloc(1, sizeof(asn_comp_rval_t));\
+              rEsUlT->err_code = COMPARE_ERR_CODE_TYPE_MISMATCH;\
+              rEsUlT->name     = aRg_tYpE_dEf1->xml_tag;\
+              return rEsUlT;\
+            }\
+          }\
+        }\
+      } else {\
+        rEsUlT             = (asn_comp_rval_t *)calloc(1, sizeof(asn_comp_rval_t));\
+        rEsUlT->name       = aRg_tYpE_dEf1->name;\
+        rEsUlT->structure1 = aRg_vAl1;\
+        rEsUlT->structure2 = aRg_vAl2;\
+        rEsUlT->err_code   = COMPARE_ERR_CODE_TYPE_ARG_NULL;\
+        return rEsUlT;\
+      }\
+      if ((NULL == aRg_vAl1) || (NULL == aRg_vAl2)){\
+        rEsUlT             = (asn_comp_rval_t *)calloc(1, sizeof(asn_comp_rval_t));\
+        rEsUlT->name       = aRg_tYpE_dEf1->name;\
+        rEsUlT->structure1 = aRg_vAl1;\
+        rEsUlT->structure2 = aRg_vAl2;\
+        rEsUlT->err_code   = COMPARE_ERR_CODE_VALUE_ARG_NULL;\
+        return rEsUlT;\
+      }\
+    } while (0);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _ASN_COMPARE_H_ */
--- skeletons/BIT_STRING.c	2015-12-08 14:39:33.346543533 +0100
+++ skeletons/BIT_STRING.c	2015-11-26 14:41:50.159616000 +0100
@@ -30,7 +30,8 @@
 	OCTET_STRING_decode_uper,	/* Unaligned PER decoder */
 	OCTET_STRING_encode_uper,	/* Unaligned PER encoder */
 	OCTET_STRING_decode_aper,	/* Aligned PER decoder */
-	OCTET_STRING_encode_aper,	/* Aligned PER encoder */
+  OCTET_STRING_encode_aper, /* Aligned PER encoder */
+  OCTET_STRING_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_BIT_STRING_tags,
 	sizeof(asn_DEF_BIT_STRING_tags)
--- skeletons/BMPString.c	2015-12-08 14:39:33.338543533 +0100
+++ skeletons/BMPString.c	2015-11-26 14:42:08.487616000 +0100
@@ -36,7 +36,8 @@
 	OCTET_STRING_decode_uper,
 	OCTET_STRING_encode_uper,
 	OCTET_STRING_decode_aper,	/* Aligned PER decoder */
-	OCTET_STRING_encode_aper,	/* Aligned PER encoder */
+  OCTET_STRING_encode_aper, /* Aligned PER encoder */
+  OCTET_STRING_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_BMPString_tags,
 	sizeof(asn_DEF_BMPString_tags)
--- skeletons/BOOLEAN.c	2015-12-08 14:39:33.342543533 +0100
+++ skeletons/BOOLEAN.c	2015-12-08 10:37:11.866558000 +0100
@@ -25,7 +25,8 @@
 	BOOLEAN_decode_uper,	/* Unaligned PER decoder */
 	BOOLEAN_encode_uper,	/* Unaligned PER encoder */
 	BOOLEAN_decode_aper,	/* Aligned PER decoder */
-	BOOLEAN_encode_aper,	/* Aligned PER encoder */
+  BOOLEAN_encode_aper,  /* Aligned PER encoder */
+  BOOLEAN_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_BOOLEAN_tags,
 	sizeof(asn_DEF_BOOLEAN_tags) / sizeof(asn_DEF_BOOLEAN_tags[0]),
@@ -326,3 +327,22 @@
 
 	_ASN_ENCODED_OK(er);
 }
+
+asn_comp_rval_t *
+BOOLEAN_compare(asn_TYPE_descriptor_t *td1,
+  void *sptr1, asn_TYPE_descriptor_t *td2, void *sptr2) {
+  const BOOLEAN_t *st1 = (const BOOLEAN_t *)sptr1;
+  const BOOLEAN_t *st2 = (const BOOLEAN_t *)sptr2;
+  asn_comp_rval_t *res = NULL;
+
+  COMPARE_CHECK_ARGS(td1, td2, sptr1, sptr2, res)
+
+  if (*st1 == *st2) return NULL;
+  res = calloc(1, sizeof(asn_comp_rval_t));
+  res->name = td1->name;
+  res->structure1 = sptr1;
+  res->structure2 = sptr2;
+  res->err_code = COMPARE_ERR_CODE_NO_MATCH;
+  return res;
+}
+
--- skeletons/BOOLEAN.h	2015-12-08 14:39:33.342543533 +0100
+++ skeletons/BOOLEAN.h	2015-11-26 12:46:58.491623000 +0100
@@ -30,6 +30,7 @@
 per_type_encoder_f BOOLEAN_encode_uper;
 per_type_decoder_f BOOLEAN_decode_aper;
 per_type_encoder_f BOOLEAN_encode_aper;
+type_compare_f     BOOLEAN_compare;
 
 #ifdef __cplusplus
 }
--- skeletons/compare.h	1970-01-01 01:00:00.000000000 +0100
+++ skeletons/compare.h	2015-12-08 08:23:03.694566000 +0100
@@ -0,0 +1,28 @@
+/*-
+ * Eurecom 2015.
+ */
+#ifndef	_COMPARE_H_
+#define	_COMPARE_H_
+
+#include <asn_application.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct asn_TYPE_descriptor_s;	/* Forward declaration */
+
+typedef asn_comp_rval_t * (type_compare_f)(
+  struct asn_TYPE_descriptor_s *type_descriptor1,
+  void *struct_ptr1,
+  struct asn_TYPE_descriptor_s *type_descriptor2,
+  void *struct_ptr2
+);
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _COMPARE_H_ */
--- skeletons/constr_CHOICE.c	2015-12-08 14:39:33.342543533 +0100
+++ skeletons/constr_CHOICE.c	2015-12-08 10:39:16.670558000 +0100
@@ -1272,3 +1272,75 @@
 		assert(pres_size != sizeof(int));
 	}
 }
+
+asn_comp_rval_t *
+CHOICE_compare(asn_TYPE_descriptor_t *td1, void *sptr1, asn_TYPE_descriptor_t *td2, void *sptr2)
+{
+  asn_CHOICE_specifics_t *specs1 = (asn_CHOICE_specifics_t *)td1->specifics;
+  asn_CHOICE_specifics_t *specs2 = (asn_CHOICE_specifics_t *)td2->specifics;
+  int present1;
+  int present2;
+  asn_comp_rval_t *res = NULL;
+
+  COMPARE_CHECK_ARGS(td1, td2, sptr1, sptr2, res)
+
+  /*
+   * Figure out which CHOICE element is encoded.
+   */
+  present1 = _fetch_present_idx(sptr1, specs1->pres_offset,specs1->pres_size);
+  // same specs
+  present2 = _fetch_present_idx(sptr2, specs2->pres_offset,specs2->pres_size);
+
+  if (td1->elements_count != td2->elements_count) {
+    res = calloc(1, sizeof(asn_comp_rval_t));
+    res->name = td1->name;
+    res->structure1 = sptr1;
+    res->structure2 = sptr2;
+    res->err_code = COMPARE_ERR_CODE_CHOICE_NUM;
+    return res;
+  }
+  if (present1 != present2) {
+    res = calloc(1, sizeof(asn_comp_rval_t));
+    res->name = td1->name;
+    res->structure1 = sptr1;
+    res->structure2 = sptr2;
+    res->err_code = COMPARE_ERR_CODE_CHOICE_PRESENT;
+    return res;
+  }
+  if(present1 > 0 && present1 <= td1->elements_count) {
+    asn_TYPE_member_t *elm1 = &td1->elements[present1-1];
+    asn_TYPE_member_t *elm2 = &td2->elements[present2-1];
+    const void *memb_ptr1;
+    const void *memb_ptr2;
+
+    if((elm1->flags & ATF_POINTER) && (elm1->flags & ATF_POINTER)){
+      memb_ptr1 = *(const void * const *)((const char *)sptr1 + elm1->memb_offset);
+      memb_ptr2 = *(const void * const *)((const char *)sptr2 + elm2->memb_offset);
+      if((!memb_ptr1) || (!memb_ptr2)) {
+        res = calloc(1, sizeof(asn_comp_rval_t));
+        res->name = td1->name;
+        res->structure1 = sptr1;
+        res->structure2 = sptr2;
+        res->err_code = COMPARE_ERR_CODE_VALUE_NULL;
+        return res;
+      }
+    } else if (!(elm1->flags & ATF_POINTER) && !(elm1->flags & ATF_POINTER)){
+      memb_ptr1 = (const void *)((const char *)sptr1 + elm1->memb_offset);
+      memb_ptr2 = (const void *)((const char *)sptr2 + elm2->memb_offset);
+    } else {
+      res = calloc(1, sizeof(asn_comp_rval_t));
+      res->name = td1->name;
+      res->structure1 = sptr1;
+      res->structure2 = sptr2;
+      res->err_code = COMPARE_ERR_CODE_CHOICE_MALFORMED;
+      return res;
+    }
+    return elm1->type->compare(elm1->type, memb_ptr1, elm2->type, memb_ptr2);
+  }
+  res = calloc(1, sizeof(asn_comp_rval_t));
+  res->name = td1->name;
+  res->structure1 = sptr1;
+  res->structure2 = sptr2;
+  res->err_code = COMPARE_ERR_CODE_CHOICE_MALFORMED;
+  return res;
+}
--- skeletons/constr_CHOICE.h	2015-12-08 14:39:33.342543533 +0100
+++ skeletons/constr_CHOICE.h	2015-11-26 14:43:57.647616000 +0100
@@ -39,7 +39,7 @@
 /*
  * A set specialized functions dealing with the CHOICE type.
  */
-asn_struct_free_f CHOICE_free;
+asn_struct_free_f  CHOICE_free;
 asn_struct_print_f CHOICE_print;
 asn_constr_check_f CHOICE_constraint;
 ber_type_decoder_f CHOICE_decode_ber;
@@ -50,7 +50,8 @@
 per_type_encoder_f CHOICE_encode_uper;
 per_type_decoder_f CHOICE_decode_aper;
 per_type_encoder_f CHOICE_encode_aper;
-asn_outmost_tag_f CHOICE_outmost_tag;
+type_compare_f     CHOICE_compare;
+asn_outmost_tag_f  CHOICE_outmost_tag;
 
 #ifdef __cplusplus
 }
--- skeletons/constr_SEQUENCE.c	2015-12-08 14:39:33.346543533 +0100
+++ skeletons/constr_SEQUENCE.c	2015-12-08 10:39:52.442558000 +0100
@@ -1761,3 +1761,66 @@
 
 	_ASN_ENCODED_OK(er);
 }
+
+asn_comp_rval_t * SEQUENCE_compare(asn_TYPE_descriptor_t *td1, void *sptr1, asn_TYPE_descriptor_t *td2, void *sptr2) {
+  int edx;
+  int ret;
+  asn_comp_rval_t *res = NULL;
+  asn_comp_rval_t *res2 = NULL;
+
+  COMPARE_CHECK_ARGS(td1, td2, sptr1, sptr2, res)
+
+  if (td1->elements_count != td2->elements_count) {
+    res = calloc(1, sizeof(asn_comp_rval_t));
+    res->name = td1->name;
+    res->structure1 = sptr1;
+    res->structure2 = sptr2;
+    res->err_code = COMPARE_ERR_CODE_COLLECTION_NUM_ELEMENTS;
+    return res;
+  }
+
+  for(edx = 0; edx < td1->elements_count; edx++) {
+    asn_TYPE_member_t *elm1 = &td1->elements[edx];
+    asn_TYPE_member_t *elm2 = &td1->elements[edx];
+    const void *memb_ptr1;
+    const void *memb_ptr2;
+
+    if(elm1->flags & ATF_POINTER) {
+      memb_ptr1 = *(const void * const *)((const char *)sptr1 + elm1->memb_offset);
+      memb_ptr2 = *(const void * const *)((const char *)sptr2 + elm2->memb_offset);
+      if((!memb_ptr1) && (!memb_ptr2)) {
+        if(elm1->optional) continue;
+      }
+      if ((!memb_ptr1) || (!memb_ptr2)) {
+        res2 = calloc(1, sizeof(asn_comp_rval_t));
+        res2->name = elm1->name;
+        res2->structure1 = memb_ptr1;
+        res2->structure2 = memb_ptr2;
+        res->err_code = COMPARE_ERR_CODE_VALUE_NULL;
+        if (NULL == res) {
+          res = res2;
+        } else {
+          res2->next = res;
+          res = res2;
+        }
+        res2 = NULL;
+      }
+    } else {
+      memb_ptr1 = (const void *)((const char *)sptr1 + elm1->memb_offset);
+      memb_ptr2 = (const void *)((const char *)sptr2 + elm2->memb_offset);
+    }
+
+    /* Compare the member itself */
+    res2 = elm1->type->compare(elm1->type, memb_ptr1, elm2->type, memb_ptr2);
+    if(res2) {
+      if (NULL == res) {
+        res = res2;
+      } else {
+        res2->next = res;
+        res = res2;
+      }
+      res2 = NULL;
+    }
+  }
+  return res;
+}
--- skeletons/constr_SEQUENCE.h	2015-12-08 14:39:33.346543533 +0100
+++ skeletons/constr_SEQUENCE.h	2015-11-26 14:48:14.123616000 +0100
@@ -54,6 +54,7 @@
 per_type_encoder_f SEQUENCE_encode_uper;
 per_type_decoder_f SEQUENCE_decode_aper;
 per_type_encoder_f SEQUENCE_encode_aper;
+type_compare_f     SEQUENCE_compare;
 
 #ifdef __cplusplus
 }
--- skeletons/constr_SEQUENCE_OF.h	2015-12-08 14:39:33.342543533 +0100
+++ skeletons/constr_SEQUENCE_OF.h	2015-11-26 15:05:25.399615000 +0100
@@ -22,7 +22,8 @@
 #define	SEQUENCE_OF_decode_ber	SET_OF_decode_ber
 #define	SEQUENCE_OF_decode_xer	SET_OF_decode_xer
 #define	SEQUENCE_OF_decode_uper	SET_OF_decode_uper
-#define	SEQUENCE_OF_decode_aper	SET_OF_decode_aper
+#define SEQUENCE_OF_decode_aper SET_OF_decode_aper
+#define SEQUENCE_OF_compare     SET_OF_compare
 der_type_encoder_f SEQUENCE_OF_encode_der;
 xer_type_encoder_f SEQUENCE_OF_encode_xer;
 per_type_encoder_f SEQUENCE_OF_encode_uper;
--- skeletons/constr_SET.c	2015-12-08 14:39:33.342543533 +0100
+++ skeletons/constr_SET.c	2015-12-08 10:40:35.066558000 +0100
@@ -1108,7 +1108,7 @@
 	}
 }
 
-int
+long
 SET_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
 		asn_app_constraint_failed_f *ctfailcb, void *app_key) {
 	int edx;
@@ -1159,3 +1159,58 @@
 
 	return 0;
 }
+
+asn_comp_rval_t *
+SET_compare(asn_TYPE_descriptor_t *td1, void *sptr1, asn_TYPE_descriptor_t *td2, void *sptr2)
+{
+  int edx;
+  asn_comp_rval_t *res = NULL;
+  asn_comp_rval_t *res2 = NULL;
+
+  COMPARE_CHECK_ARGS(td1, td2, sptr1, sptr2, res)
+
+  if (td1->elements_count != td2->elements_count) {
+    res = calloc(1, sizeof(asn_comp_rval_t));
+    res->name = td1->name;
+    res->structure1 = sptr1;
+    res->structure2 = sptr2;
+    res->err_code = COMPARE_ERR_CODE_COLLECTION_NUM_ELEMENTS;
+    return res;
+  }
+
+  for(edx = 0; edx < td1->elements_count; edx++) {
+    asn_TYPE_member_t *elm1 = &td1->elements[edx];
+    asn_TYPE_member_t *elm2 = &td2->elements[edx];
+    const void *memb_ptr1;
+    const void *memb_ptr2;
+
+    if(elm1->flags & ATF_POINTER) {
+      memb_ptr1 = *(const void * const *)((const char *)sptr1 + elm1->memb_offset);
+      memb_ptr2 = *(const void * const *)((const char *)sptr2 + elm2->memb_offset);
+      if(!memb_ptr1) {
+        if(elm1->optional)
+          continue;
+        res = calloc(1, sizeof(asn_comp_rval_t));
+        res->name = td1->name;
+        res->structure1 = sptr1;
+        res->structure2 = sptr2;
+        res->err_code = COMPARE_ERR_CODE_SET_MALFORMED;
+        return res;
+      }
+    } else {
+      memb_ptr1 = (const void *)((const char *)sptr1 + elm1->memb_offset);
+      memb_ptr2 = (const void *)((const char *)sptr2 + elm2->memb_offset);
+    }
+    res2 = elm1->type->compare(elm1->type, memb_ptr1, elm2->type, memb_ptr2);
+    if(res2) {
+      if (NULL == res) {
+        res = res2;
+      } else {
+        res2->next = res;
+        res = res2;
+      }
+      res2 = NULL;
+    }
+  }
+  return res;
+}
--- skeletons/constr_SET.h	2015-12-08 14:39:33.342543533 +0100
+++ skeletons/constr_SET.h	2015-11-26 14:49:09.243616000 +0100
@@ -56,6 +56,7 @@
 per_type_decoder_f SET_decode_aper;
 per_type_encoder_f SET_encode_uper;
 per_type_encoder_f SET_encode_aper;
+type_compare_f     SET_compare;
 
 /***********************
  * Some handy helpers. *
--- skeletons/constr_SET_OF.c	2015-12-08 14:39:33.338543533 +0100
+++ skeletons/constr_SET_OF.c	2015-12-08 10:45:54.466557000 +0100
@@ -1039,3 +1039,55 @@
 	rv.consumed = 0;
 	return rv;
 }
+
+asn_comp_rval_t *
+SET_OF_compare(asn_TYPE_descriptor_t *td1, void *sptr1, asn_TYPE_descriptor_t *td2, void *sptr2)
+{
+  asn_TYPE_member_t *elm1 = td1->elements;
+  asn_TYPE_member_t *elm2 = td2->elements;
+  const asn_anonymous_set_ *list1 = _A_CSET_FROM_VOID(sptr1);
+  const asn_anonymous_set_ *list2 = _A_CSET_FROM_VOID(sptr2);
+  int ret;
+  int i;
+  asn_comp_rval_t *res = NULL;
+  asn_comp_rval_t *res2 = NULL;
+
+  COMPARE_CHECK_ARGS(td1, td2, sptr1, sptr2, res)
+
+  if (td1->elements_count != td2->elements_count) {
+    res = calloc(1, sizeof(asn_comp_rval_t));
+    res->name = td1->name;
+    res->structure1 = sptr1;
+    res->structure2 = sptr2;
+    res->err_code = COMPARE_ERR_CODE_COLLECTION_NUM_ELEMENTS;
+    return res;
+  }
+
+
+  if (list1->count != list2->count ) {
+    res = calloc(1, sizeof(asn_comp_rval_t));
+    res->name = td1->name;
+    res->structure1 = sptr1;
+    res->structure2 = sptr2;
+    res->err_code = COMPARE_ERR_CODE_COLLECTION_NUM_ELEMENTS;
+    return res;
+  }
+
+  for(i = 0; i < list1->count; i++) {
+    const void *memb_ptr1 = list1->array[i];
+    const void *memb_ptr2 = list2->array[i];
+    if ((!memb_ptr1) & (!memb_ptr2)) continue;
+
+    res2 = elm1->type->compare(elm1->type, memb_ptr1, elm2->type, memb_ptr2);
+    if(res2) {
+      if (NULL == res) {
+        res = res2;
+      } else {
+        res2->next = res;
+        res = res2;
+      }
+      res2 = NULL;
+    }
+  }
+  return  res;
+}
--- skeletons/constr_SET_OF.h	2015-12-08 14:39:33.338543533 +0100
+++ skeletons/constr_SET_OF.h	2015-11-26 14:48:45.067616000 +0100
@@ -36,6 +36,7 @@
 per_type_encoder_f SET_OF_encode_uper;
 per_type_decoder_f SET_OF_decode_aper;
 per_type_encoder_f SET_OF_encode_aper;
+type_compare_f     SET_OF_compare;
 
 #ifdef __cplusplus
 }
--- skeletons/constr_TYPE.h	2015-12-08 14:39:33.338543533 +0100
+++ skeletons/constr_TYPE.h	2015-11-26 15:28:05.495613000 +0100
@@ -41,7 +41,8 @@
 #include <xer_encoder.h>	/* Encoder into XER (XML, text) */
 #include <per_decoder.h>	/* Packet Encoding Rules decoder */
 #include <per_encoder.h>	/* Packet Encoding Rules encoder */
-#include <constraints.h>	/* Subtype constraints support */
+#include <constraints.h>  /* Subtype constraints support */
+#include <compare.h>      /* Comparison */
 
 /*
  * Free the structure according to its specification.
@@ -101,6 +102,7 @@
 	per_type_encoder_f *uper_encoder;	/* Unaligned PER encoder */
 	per_type_decoder_f *aper_decoder;	/* Aligned PER decoder */
 	per_type_encoder_f *aper_encoder;	/* Aligned PER encoder */
+	type_compare_f     *compare;      /* Comparison between 2 instances */
 
 	/***********************************************************************
 	 * Internally useful members. Not to be used by applications directly. *
--- skeletons/ENUMERATED.c	2015-12-08 14:39:33.342543533 +0100
+++ skeletons/ENUMERATED.c	2015-12-08 10:40:55.986558000 +0100
@@ -27,7 +27,8 @@
 	ENUMERATED_decode_uper,	/* Unaligned PER decoder */
 	ENUMERATED_encode_uper,	/* Unaligned PER encoder */
 	ENUMERATED_decode_aper,	/* Aligned PER decoder */
-	ENUMERATED_encode_aper,	/* Aligned PER encoder */
+  ENUMERATED_encode_aper, /* Aligned PER encoder */
+  ENUMERATED_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_ENUMERATED_tags,
 	sizeof(asn_DEF_ENUMERATED_tags) / sizeof(asn_DEF_ENUMERATED_tags[0]),
@@ -103,3 +104,22 @@
 	
 	return NativeEnumerated_encode_aper(td, constraints, &value, po);
 }
+
+asn_comp_rval_t *
+ENUMERATED_compare(asn_TYPE_descriptor_t *td1, void *sptr1,
+                   asn_TYPE_descriptor_t *td2, void *sptr2) {
+  ENUMERATED_t *st1 = (ENUMERATED_t *)sptr1;
+  ENUMERATED_t *st2 = (ENUMERATED_t *)sptr2;
+  asn_comp_rval_t *res = NULL;
+
+  COMPARE_CHECK_ARGS(td1, td2, sptr1, sptr2, res)
+
+  if (*st1 == *st2) return NULL;
+  res = calloc(1, sizeof(asn_comp_rval_t));
+  res->name = td1->name;
+  res->structure1 = sptr1;
+  res->structure2 = sptr2;
+  res->err_code = COMPARE_ERR_CODE_NO_MATCH;
+  return res;
+}
+
--- skeletons/ENUMERATED.h	2015-12-08 14:39:33.342543533 +0100
+++ skeletons/ENUMERATED.h	2015-11-26 12:46:35.523623000 +0100
@@ -19,6 +19,7 @@
 per_type_encoder_f ENUMERATED_encode_uper;
 per_type_decoder_f ENUMERATED_decode_aper;
 per_type_encoder_f ENUMERATED_encode_aper;
+type_compare_f     ENUMERATED_compare;
 
 #ifdef __cplusplus
 }
--- skeletons/file-dependencies	2015-12-08 14:39:12.678543554 +0100
+++ skeletons/file-dependencies	2015-12-07 15:34:40.454629000 +0100
@@ -39,12 +39,13 @@
 constr_SEQUENCE.h constr_SEQUENCE.c
 constr_SEQUENCE_OF.h constr_SEQUENCE_OF.c asn_SEQUENCE_OF.h constr_SET_OF.h
 constr_SET.h constr_SET.c
-constr_SET_OF.h constr_SET_OF.c asn_SET_OF.h
+constr_SET_OF.h constr_SET_OF.c asn_SET_OF.h compare.h
 
 COMMON-FILES:			# THIS IS A SPECIAL SECTION
-asn_application.h		# Applications should include this file
+asn_application.h   # Applications should include this file
 asn_system.h			# Platform-dependent types
-asn_codecs.h			# Return types of encoders and decoders
+asn_codecs.h      # Return types of encoders and decoders
+asn_compare.h     # Return type of compare
 asn_internal.h			# Internal stuff
 OCTET_STRING.h OCTET_STRING.c	# This one is used too widely
 BIT_STRING.h BIT_STRING.c	# This one is necessary for the above one
--- skeletons/GeneralizedTime.c	2015-12-08 14:39:33.350543533 +0100
+++ skeletons/GeneralizedTime.c	2015-11-26 15:09:03.899615000 +0100
@@ -168,7 +168,8 @@
 	OCTET_STRING_decode_uper,
 	OCTET_STRING_encode_uper,
 	OCTET_STRING_decode_aper,
-	OCTET_STRING_encode_aper,
+  OCTET_STRING_encode_aper,
+  OCTET_STRING_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_GeneralizedTime_tags,
 	sizeof(asn_DEF_GeneralizedTime_tags)
--- skeletons/GeneralString.c	2015-12-08 14:39:33.342543533 +0100
+++ skeletons/GeneralString.c	2015-11-26 14:50:11.843616000 +0100
@@ -25,7 +25,8 @@
 	OCTET_STRING_decode_uper,    /* Implemented in terms of OCTET STRING */
 	OCTET_STRING_encode_uper,
 	OCTET_STRING_decode_aper,
-	OCTET_STRING_encode_aper,
+  OCTET_STRING_encode_aper,
+  OCTET_STRING_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_GeneralString_tags,
 	sizeof(asn_DEF_GeneralString_tags)
--- skeletons/GraphicString.c	2015-12-08 14:39:33.350543533 +0100
+++ skeletons/GraphicString.c	2015-11-26 15:33:33.255613000 +0100
@@ -25,7 +25,8 @@
 	OCTET_STRING_decode_uper,    /* Implemented in terms of OCTET STRING */
 	OCTET_STRING_encode_uper,
 	OCTET_STRING_decode_aper,
-	OCTET_STRING_encode_aper,
+  OCTET_STRING_encode_aper,
+  OCTET_STRING_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_GraphicString_tags,
 	sizeof(asn_DEF_GraphicString_tags)
--- skeletons/IA5String.c	2015-12-08 14:39:33.342543533 +0100
+++ skeletons/IA5String.c	2015-11-26 14:50:44.219616000 +0100
@@ -31,6 +31,7 @@
 	OCTET_STRING_encode_uper,
 	OCTET_STRING_decode_aper,
 	OCTET_STRING_encode_aper,
+	OCTET_STRING_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_IA5String_tags,
 	sizeof(asn_DEF_IA5String_tags)
--- skeletons/INTEGER.c	2015-12-08 14:39:33.346543533 +0100
+++ skeletons/INTEGER.c	2015-12-08 10:41:08.526558000 +0100
@@ -35,6 +35,7 @@
 	INTEGER_decode_aper,
 	INTEGER_encode_aper,
 #endif	/* ASN_DISABLE_PER_SUPPORT */
+	INTEGER_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_INTEGER_tags,
 	sizeof(asn_DEF_INTEGER_tags) / sizeof(asn_DEF_INTEGER_tags[0]),
@@ -1501,3 +1502,30 @@
 }
 
 
+asn_comp_rval_t *
+INTEGER_compare(asn_TYPE_descriptor_t *td1, void *sptr1,
+                asn_TYPE_descriptor_t *td2, void *sptr2) {
+  INTEGER_t *st1 = (INTEGER_t *)sptr1;
+  INTEGER_t *st2 = (INTEGER_t *)sptr2;
+  asn_comp_rval_t *res = NULL;
+
+  COMPARE_CHECK_ARGS(td1, td2, sptr1, sptr2, res)
+
+  if (st1->size != st2->size) {
+    res = calloc(1, sizeof(asn_comp_rval_t));
+    res->name = td1->name;
+    res->structure1 = sptr1;
+    res->structure2 = sptr2;
+    res->err_code = COMPARE_ERR_CODE_NO_MATCH;
+    return res;
+  }
+  if (0 != memcmp(st1->buf, st2->buf, st1->size)) {
+    res = calloc(1, sizeof(asn_comp_rval_t));
+    res->name = td1->name;
+    res->structure1 = sptr1;
+    res->structure2 = sptr2;
+    res->err_code = COMPARE_ERR_CODE_NO_MATCH;
+    return res;
+  }
+  return NULL;
+}
--- skeletons/INTEGER.h	2015-12-08 14:39:33.346543533 +0100
+++ skeletons/INTEGER.h	2015-11-26 12:50:41.551623000 +0100
@@ -43,6 +43,7 @@
 per_type_encoder_f INTEGER_encode_uper;
 per_type_decoder_f INTEGER_decode_aper;
 per_type_encoder_f INTEGER_encode_aper;
+type_compare_f     INTEGER_compare;
 
 /***********************************
  * Some handy conversion routines. *
--- skeletons/ISO646String.c	2015-12-08 14:39:33.342543533 +0100
+++ skeletons/ISO646String.c	2015-11-26 12:55:48.327623000 +0100
@@ -30,7 +30,8 @@
 	OCTET_STRING_decode_uper,
 	OCTET_STRING_encode_uper,
 	OCTET_STRING_decode_aper,
-	OCTET_STRING_encode_aper,
+  OCTET_STRING_encode_aper,
+  OCTET_STRING_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_ISO646String_tags,
 	sizeof(asn_DEF_ISO646String_tags)
--- skeletons/Makefile.am	2015-12-08 14:39:12.666543554 +0100
+++ skeletons/Makefile.am	2015-12-07 15:54:00.150628000 +0100
@@ -46,11 +46,11 @@
 	asn_SET_OF.c asn_SET_OF.h			\
 	asn_application.h asn_codecs.h			\
 	asn_codecs_prim.c asn_codecs_prim.h		\
-	asn_internal.h asn_system.h			\
+	asn_internal.h asn_system.h asn_compare.h			\
 	ber_decoder.c ber_decoder.h			\
 	ber_tlv_length.c ber_tlv_length.h		\
-	ber_tlv_tag.c ber_tlv_tag.h			\
-	constr_CHOICE.c constr_CHOICE.h			\
+	ber_tlv_tag.c ber_tlv_tag.h compare.h			\
+	comparison.h constr_CHOICE.c constr_CHOICE.h			\
 	constr_SEQUENCE.c constr_SEQUENCE.h		\
 	constr_SEQUENCE_OF.c constr_SEQUENCE_OF.h	\
 	constr_SET.c constr_SET.h			\
--- skeletons/NativeEnumerated.c	2015-12-08 14:39:33.342543533 +0100
+++ skeletons/NativeEnumerated.c	2015-12-08 10:41:17.662558000 +0100
@@ -31,7 +31,8 @@
 	NativeEnumerated_decode_uper,
 	NativeEnumerated_encode_uper,
 	NativeEnumerated_decode_aper,
-	NativeEnumerated_encode_aper,
+  NativeEnumerated_encode_aper,
+  NativeEnumerated_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_NativeEnumerated_tags,
 	sizeof(asn_DEF_NativeEnumerated_tags) / sizeof(asn_DEF_NativeEnumerated_tags[0]),
@@ -335,3 +336,22 @@
 
 	_ASN_ENCODED_OK(er);
 }
+
+asn_comp_rval_t *
+NativeEnumerated_compare(asn_TYPE_descriptor_t *td1, void *sptr1,
+    asn_TYPE_descriptor_t *td2, void *sptr2) {
+  const asn_INTEGER_enum_map_t *a = sptr1;
+  const asn_INTEGER_enum_map_t *b = sptr2;
+  asn_comp_rval_t *res = NULL;
+
+  COMPARE_CHECK_ARGS(td1, td2, sptr1, sptr2, res)
+
+  if(a->nat_value == b->nat_value)
+    return NULL;
+  res = calloc(1, sizeof(asn_comp_rval_t));
+  res->name = td1->name;
+  res->structure1 = sptr1;
+  res->structure2 = sptr2;
+  res->err_code = COMPARE_ERR_CODE_NO_MATCH;
+  return res;
+}
--- skeletons/NativeEnumerated.h	2015-12-08 14:39:33.342543533 +0100
+++ skeletons/NativeEnumerated.h	2015-11-26 14:51:43.315616000 +0100
@@ -26,6 +26,7 @@
 per_type_encoder_f NativeEnumerated_encode_uper;
 per_type_decoder_f NativeEnumerated_decode_aper;
 per_type_encoder_f NativeEnumerated_encode_aper;
+type_compare_f     NativeEnumerated_compare;
 
 #ifdef __cplusplus
 }
--- skeletons/NativeInteger.c	2015-12-08 14:39:33.346543533 +0100
+++ skeletons/NativeInteger.c	2015-12-08 10:41:24.550558000 +0100
@@ -32,7 +32,8 @@
 	NativeInteger_decode_uper,	/* Unaligned PER decoder */
 	NativeInteger_encode_uper,	/* Unaligned PER encoder */
 	NativeInteger_decode_aper,	/* Aligned PER decoder */
-	NativeInteger_encode_aper,	/* Aligned PER encoder */
+  NativeInteger_encode_aper,  /* Aligned PER encoder */
+  NativeInteger_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_NativeInteger_tags,
 	sizeof(asn_DEF_NativeInteger_tags) / sizeof(asn_DEF_NativeInteger_tags[0]),
@@ -410,3 +411,21 @@
 	}
 }
 
+
+asn_comp_rval_t *
+NativeInteger_compare(asn_TYPE_descriptor_t *td1, void *sptr1,
+                      asn_TYPE_descriptor_t *td2, void *sptr2) {
+  const long *native1 = (const long *)sptr1;
+  const long *native2 = (const long *)sptr2;
+  asn_comp_rval_t *res = NULL;
+
+  COMPARE_CHECK_ARGS(td1, td2, sptr1, sptr2, res)
+
+  if (*native1 == *native2) return NULL;
+  res = calloc(1, sizeof(asn_comp_rval_t));
+  res->name = td1->name;
+  res->structure1 = sptr1;
+  res->structure2 = sptr2;
+  res->err_code = COMPARE_ERR_CODE_NO_MATCH;
+  return res;
+}
--- skeletons/NativeInteger.h	2015-12-08 14:39:33.346543533 +0100
+++ skeletons/NativeInteger.h	2015-11-26 14:52:13.931616000 +0100
@@ -31,6 +31,7 @@
 per_type_encoder_f NativeInteger_encode_uper;
 per_type_decoder_f NativeInteger_decode_aper;
 per_type_encoder_f NativeInteger_encode_aper;
+type_compare_f     NativeInteger_compare;
 
 #ifdef __cplusplus
 }
--- skeletons/NativeReal.c	2015-12-08 14:39:33.350543533 +0100
+++ skeletons/NativeReal.c	2015-12-08 10:41:32.666558000 +0100
@@ -33,7 +33,8 @@
 	NativeReal_decode_uper,
 	NativeReal_encode_uper,
 	NativeReal_decode_aper,
-	NativeReal_encode_aper,
+  NativeReal_encode_aper,
+  NativeReal_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_NativeReal_tags,
 	sizeof(asn_DEF_NativeReal_tags) / sizeof(asn_DEF_NativeReal_tags[0]),
@@ -405,3 +406,30 @@
 	}
 }
 
+asn_comp_rval_t *
+NativeReal_compare(asn_TYPE_descriptor_t *td1, void *sptr1,
+                   asn_TYPE_descriptor_t *td2, void *sptr2) {
+  REAL_t *st1 = (REAL_t *)sptr1;
+  REAL_t *st2 = (REAL_t *)sptr2;
+  asn_comp_rval_t *res = NULL;
+
+  COMPARE_CHECK_ARGS(td1, td2, sptr1, sptr2, res)
+
+  if (st1->size != st2->size) {
+    res = calloc(1, sizeof(asn_comp_rval_t));
+    res->name = td1->name;
+    res->structure1 = sptr1;
+    res->structure2 = sptr2;
+    res->err_code = COMPARE_ERR_CODE_NO_MATCH;
+    return res;
+  }
+  if (0 != memcmp(st1->buf, st2->buf, st1->size)) {
+    res = calloc(1, sizeof(asn_comp_rval_t));
+    res->name = td1->name;
+    res->structure1 = sptr1;
+    res->structure2 = sptr2;
+    res->err_code = COMPARE_ERR_CODE_NO_MATCH;
+    return res;
+  }
+  return NULL;
+}
--- skeletons/NativeReal.h	2015-12-08 14:39:33.350543533 +0100
+++ skeletons/NativeReal.h	2015-11-26 14:31:12.631617000 +0100
@@ -29,6 +29,7 @@
 per_type_encoder_f NativeReal_encode_uper;
 per_type_decoder_f NativeReal_decode_aper;
 per_type_encoder_f NativeReal_encode_aper;
+type_compare_f     NativeReal_compare;
 
 #ifdef __cplusplus
 }
--- skeletons/NULL.c	2015-12-08 14:39:33.338543533 +0100
+++ skeletons/NULL.c	2015-12-07 10:49:05.178647000 +0100
@@ -26,7 +26,8 @@
 	NULL_decode_uper,	/* Unaligned PER decoder */
 	NULL_encode_uper,	/* Unaligned PER encoder */
 	NULL_decode_aper,	/* Aligned PER decoder */
-	NULL_encode_aper,	/* Aligned PER encoder */
+  NULL_encode_aper, /* Aligned PER encoder */
+  NULL_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_NULL_tags,
 	sizeof(asn_DEF_NULL_tags) / sizeof(asn_DEF_NULL_tags[0]),
@@ -192,3 +193,10 @@
 	er.encoded = 0;
 	_ASN_ENCODED_OK(er);
 }
+
+asn_comp_rval_t *
+NULL_compare(asn_TYPE_descriptor_t *td1, void *sptr1,
+             asn_TYPE_descriptor_t *td2, void *sptr2) {
+
+  return NULL;
+}
--- skeletons/NULL.h	2015-12-08 14:39:33.338543533 +0100
+++ skeletons/NULL.h	2015-11-26 14:53:03.875616000 +0100
@@ -27,6 +27,7 @@
 per_type_encoder_f NULL_encode_uper;
 per_type_decoder_f NULL_decode_aper;
 per_type_encoder_f NULL_encode_aper;
+type_compare_f     NULL_compare;
 
 #ifdef __cplusplus
 }
--- skeletons/NumericString.c	2015-12-08 14:39:33.338543533 +0100
+++ skeletons/NumericString.c	2015-11-26 14:40:39.407616000 +0100
@@ -50,7 +50,8 @@
 	OCTET_STRING_decode_uper,
 	OCTET_STRING_encode_uper,
 	OCTET_STRING_decode_aper,
-	OCTET_STRING_encode_aper,
+  OCTET_STRING_encode_aper,
+  OCTET_STRING_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_NumericString_tags,
 	sizeof(asn_DEF_NumericString_tags)
--- skeletons/ObjectDescriptor.c	2015-12-08 14:39:33.338543533 +0100
+++ skeletons/ObjectDescriptor.c	2015-11-26 14:55:46.227615000 +0100
@@ -25,7 +25,8 @@
 	OCTET_STRING_decode_uper,
 	OCTET_STRING_encode_uper,
 	OCTET_STRING_decode_aper,
-	OCTET_STRING_encode_aper,
+  OCTET_STRING_encode_aper,
+  OCTET_STRING_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_ObjectDescriptor_tags,
 	sizeof(asn_DEF_ObjectDescriptor_tags)
--- skeletons/OBJECT_IDENTIFIER.c	2015-12-08 14:39:33.342543533 +0100
+++ skeletons/OBJECT_IDENTIFIER.c	2015-11-26 14:55:13.311615000 +0100
@@ -28,7 +28,8 @@
 	OCTET_STRING_decode_uper,
 	OCTET_STRING_encode_uper,
 	OCTET_STRING_decode_aper,
-	OCTET_STRING_encode_aper,
+  OCTET_STRING_encode_aper,
+  OCTET_STRING_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_OBJECT_IDENTIFIER_tags,
 	sizeof(asn_DEF_OBJECT_IDENTIFIER_tags)
--- skeletons/OCTET_STRING.c	2015-12-08 14:39:44.554543521 +0100
+++ skeletons/OCTET_STRING.c	2015-12-08 10:41:42.838558000 +0100
@@ -37,7 +37,8 @@
 	OCTET_STRING_decode_uper,	/* Unaligned PER decoder */
 	OCTET_STRING_encode_uper,	/* Unaligned PER encoder */
 	OCTET_STRING_decode_aper,	/* Aligned PER decoder */
-	OCTET_STRING_encode_aper,	/* Aligned PER encoder */
+  OCTET_STRING_encode_aper, /* Aligned PER encoder */
+  OCTET_STRING_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_OCTET_STRING_tags,
 	sizeof(asn_DEF_OCTET_STRING_tags)
@@ -2160,3 +2161,30 @@
 	return st;
 }
 
+asn_comp_rval_t *
+OCTET_STRING_compare(asn_TYPE_descriptor_t *td1,
+  void *sptr1, asn_TYPE_descriptor_t *td2, void *sptr2) {
+  OCTET_STRING_t *st1 = (OCTET_STRING_t *)sptr1;
+  OCTET_STRING_t *st2 = (OCTET_STRING_t *)sptr2;
+  asn_comp_rval_t *res = NULL;
+
+  COMPARE_CHECK_ARGS(td1, td2, sptr1, sptr2, res)
+
+  if (st1->size != st2->size) {
+    res = calloc(1, sizeof(asn_comp_rval_t));
+    res->name = td1->name;
+    res->structure1 = sptr1;
+    res->structure2 = sptr2;
+    res->err_code = COMPARE_ERR_CODE_NO_MATCH;
+    return res;
+  }
+  if (0 != memcmp(st1->buf, st2->buf, st1->size)) {
+    res = calloc(1, sizeof(asn_comp_rval_t));
+    res->name = td1->name;
+    res->structure1 = sptr1;
+    res->structure2 = sptr2;
+    res->err_code = COMPARE_ERR_CODE_NO_MATCH;
+    return res;
+  }
+  return NULL;
+}
--- skeletons/OCTET_STRING.h	2015-12-08 14:39:33.350543533 +0100
+++ skeletons/OCTET_STRING.h	2015-11-26 12:56:15.259623000 +0100
@@ -34,6 +34,7 @@
 per_type_encoder_f OCTET_STRING_encode_uper;
 per_type_decoder_f OCTET_STRING_decode_aper;
 per_type_encoder_f OCTET_STRING_encode_aper;
+type_compare_f     OCTET_STRING_compare;
 
 /******************************
  * Handy conversion routines. *
--- skeletons/PrintableString.c	2015-12-08 14:39:33.338543533 +0100
+++ skeletons/PrintableString.c	2015-11-26 14:56:09.787615000 +0100
@@ -60,7 +60,8 @@
 	OCTET_STRING_decode_uper,
 	OCTET_STRING_encode_uper,
 	OCTET_STRING_decode_aper,
-	OCTET_STRING_encode_aper,
+  OCTET_STRING_encode_aper,
+  OCTET_STRING_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_PrintableString_tags,
 	sizeof(asn_DEF_PrintableString_tags)
--- skeletons/REAL.c	2015-12-08 14:39:33.350543533 +0100
+++ skeletons/REAL.c	2015-12-08 10:41:55.178558000 +0100
@@ -46,7 +46,8 @@
 	REAL_decode_uper,
 	REAL_encode_uper,
 	REAL_decode_aper,
-	REAL_encode_aper,
+  REAL_encode_aper,
+  REAL_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_REAL_tags,
 	sizeof(asn_DEF_REAL_tags) / sizeof(asn_DEF_REAL_tags[0]),
@@ -741,3 +742,32 @@
 
 	return 0;
 }
+
+
+asn_comp_rval_t *
+REAL_compare(asn_TYPE_descriptor_t *td1, void *sptr1,
+             asn_TYPE_descriptor_t *td2,  void *sptr2) {
+  REAL_t *st1 = (REAL_t *)sptr1;
+  REAL_t *st2 = (REAL_t *)sptr2;
+  asn_comp_rval_t *res = NULL;
+
+  COMPARE_CHECK_ARGS(td1, td2, sptr1, sptr2, res)
+
+  if (st1->size != st2->size) {
+    res = calloc(1, sizeof(asn_comp_rval_t));
+    res->name = td1->name;
+    res->structure1 = sptr1;
+    res->structure2 = sptr2;
+    res->err_code = COMPARE_ERR_CODE_NO_MATCH;
+    return res;
+  }
+  if (0 != memcmp(st1->buf, st2->buf, st1->size)) {
+    res = calloc(1, sizeof(asn_comp_rval_t));
+    res->name = td1->name;
+    res->structure1 = sptr1;
+    res->structure2 = sptr2;
+    res->err_code = COMPARE_ERR_CODE_NO_MATCH;
+    return res;
+  }
+  return NULL;
+}
--- skeletons/REAL.h	2015-12-08 14:39:33.350543533 +0100
+++ skeletons/REAL.h	2015-11-26 13:00:46.183623000 +0100
@@ -23,6 +23,7 @@
 per_type_encoder_f REAL_encode_uper;
 per_type_decoder_f REAL_decode_aper;
 per_type_encoder_f REAL_encode_aper;
+type_compare_f     REAL_compare;
 
 /***********************************
  * Some handy conversion routines. *
--- skeletons/RELATIVE-OID.c	2015-12-08 14:39:33.338543533 +0100
+++ skeletons/RELATIVE-OID.c	2015-11-26 14:56:31.703615000 +0100
@@ -29,7 +29,8 @@
 	OCTET_STRING_decode_uper,
 	OCTET_STRING_encode_uper,
 	OCTET_STRING_decode_aper,
-	OCTET_STRING_encode_aper,
+  OCTET_STRING_encode_aper,
+  OCTET_STRING_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_RELATIVE_OID_tags,
 	sizeof(asn_DEF_RELATIVE_OID_tags)
--- skeletons/T61String.c	2015-12-08 14:39:33.338543533 +0100
+++ skeletons/T61String.c	2015-11-26 14:57:07.235615000 +0100
@@ -25,7 +25,8 @@
 	OCTET_STRING_decode_uper,
 	OCTET_STRING_encode_uper,
 	OCTET_STRING_decode_aper,
-	OCTET_STRING_encode_aper,
+  OCTET_STRING_encode_aper,
+  OCTET_STRING_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_T61String_tags,
 	sizeof(asn_DEF_T61String_tags)
--- skeletons/TeletexString.c	2015-12-08 14:39:33.338543533 +0100
+++ skeletons/TeletexString.c	2015-11-26 14:57:17.643615000 +0100
@@ -25,7 +25,8 @@
 	OCTET_STRING_decode_uper,
 	OCTET_STRING_encode_uper,
 	OCTET_STRING_decode_aper,
-	OCTET_STRING_encode_aper,
+  OCTET_STRING_encode_aper,
+  OCTET_STRING_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_TeletexString_tags,
 	sizeof(asn_DEF_TeletexString_tags)
--- skeletons/UniversalString.c	2015-12-08 14:39:33.350543533 +0100
+++ skeletons/UniversalString.c	2015-11-26 14:57:29.015615000 +0100
@@ -36,7 +36,8 @@
 	OCTET_STRING_decode_uper,
 	OCTET_STRING_encode_uper,
 	OCTET_STRING_decode_aper,
-	OCTET_STRING_encode_aper,
+  OCTET_STRING_encode_aper,
+  OCTET_STRING_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_UniversalString_tags,
 	sizeof(asn_DEF_UniversalString_tags)
--- skeletons/UTCTime.c	2015-12-08 14:39:33.350543533 +0100
+++ skeletons/UTCTime.c	2015-11-26 14:57:44.127615000 +0100
@@ -41,7 +41,8 @@
 	OCTET_STRING_decode_uper,
 	OCTET_STRING_encode_uper,
 	OCTET_STRING_decode_aper,
-	OCTET_STRING_encode_aper,
+  OCTET_STRING_encode_aper,
+  OCTET_STRING_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_UTCTime_tags,
 	sizeof(asn_DEF_UTCTime_tags)
--- skeletons/UTF8String.c	2015-12-08 14:39:33.314543533 +0100
+++ skeletons/UTF8String.c	2015-11-26 14:06:54.563618000 +0100
@@ -27,6 +27,7 @@
 	OCTET_STRING_encode_uper,
 	OCTET_STRING_decode_aper,
 	OCTET_STRING_encode_aper,
+  OCTET_STRING_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_UTF8String_tags,
 	sizeof(asn_DEF_UTF8String_tags)
--- skeletons/VideotexString.c	2015-12-08 14:39:33.342543533 +0100
+++ skeletons/VideotexString.c	2015-11-26 14:07:06.139618000 +0100
@@ -25,7 +25,8 @@
 	OCTET_STRING_decode_uper,    /* Implemented in terms of OCTET STRING */
 	OCTET_STRING_encode_uper,
 	OCTET_STRING_decode_aper,
-	OCTET_STRING_encode_aper,
+  OCTET_STRING_encode_aper,
+  OCTET_STRING_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_VideotexString_tags,
 	sizeof(asn_DEF_VideotexString_tags)
--- skeletons/VisibleString.c	2015-12-08 14:39:33.350543533 +0100
+++ skeletons/VisibleString.c	2015-11-26 14:07:15.283618000 +0100
@@ -30,7 +30,8 @@
 	OCTET_STRING_decode_uper,
 	OCTET_STRING_encode_uper,
 	OCTET_STRING_decode_aper,
-	OCTET_STRING_encode_aper,
+  OCTET_STRING_encode_aper,
+  OCTET_STRING_compare,
 	0, /* Use generic outmost tag fetcher */
 	asn_DEF_VisibleString_tags,
 	sizeof(asn_DEF_VisibleString_tags)
